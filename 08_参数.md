

```shell
# Sort_Buffer_Size
Sort_Buffer_Size 是一个connection级参数，在每个connection第一次需要使用这个buffer的时候，一次性分配设置的内存。
Sort_Buffer_Size 并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统内存资源

# read_buffer_size
read_buffer_size：是MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能

# read_rnd_buffer_size
这个参数用在sort查询之后 ，以保证获取以顺序的方式获取到查询的数据。如果你有很多order by 查询语句，增长这值能够提升性能。”
  老实说，这个参数和read_buffer_size很像，read_buffer_size仅仅用于MyISAM引擎
read_rnd_buffer_size不仅仅用在MyISAM引擎，而是用在所有引擎。它用在查询后，对读取真正的数据进行优化。它是这样工作的：
  sort后，得到的是行数据指针，通过key-value的形式存在，对于MyISAM是数据的偏移量，对于innodb是主键或存储重新查询的全量数据（对于小片的数据是有益的）。
  假设sort后的数据使用的是行指针，并且行中的字段能够被转换成固定的大小（除了BLOB/TEXT字段外），MySQL能够使用read_rnd_buffer_size优化数据读取。
  因为sort后的数据是以key-value的形式存在的，使用这些行指针去读取数据，将是以指针数据物理的顺序去读取，很大程度上是随机的方式读取数据的。MySQL从sort_buffer中读取这些行指针数据，然后通过指针排序后存入read_rnd_buffer中，之后再通过指针读取数据时，基本上都是顺序读取了。
  read_rnd_buffer_size是很重要的参数，尤其工作在如下场景：
     * sort_buffer中存的是行指针而不是要查询的数据。
     * 查询的字段中包含Blob/Text字段。
     * sort后有大量的数据行（limit 10并不能帮助你，因为MySQL是通过指针获取行数据的）
  如果你取出很少字段的数据（小于max_length_for_sort_data）,行数据将会全部存储在sort buffer里，因此将不需要read_rnd_buffer_size这个参数。而如果你查询的字段数据很长（这些字段很可能含有Text/Blob字段），比max_length_for_sort_data还长，read_rnd_buffer_size这个参数将派上用场。
  
# 通用类

# key_buffer_size
含义：用于索引块的缓冲区大小，增加它可得到更好处理的索引（对所有读和多重写）。
影响：对于MyISAM表的影响不是很大，MyISAM会使用系统的缓存来存储数据，所以大量使用MyISAM表的机器内存很快就会耗尽。但是，如果你将该值设得过大（例如，大于总内存的50%），系统将转换为页并变得极慢。MySQL依赖操作系统来执行数据读取时的文件系统缓存，因此你必须为文件系统缓存留一些空间。
建议：先设置为内存的25%，观察性能变化。

#table_open_cache
含义：为所有线程打开表的数量。
影响：增加该值能增加mysqld要求的文件描述符的数量。可以避免频繁的打开数据表产生的开销。打开一个表的开销可能很大，因为MyISAM会把MYI文件的文件头标识为正在使用，所以在内存中做这个操作比较好。，因为每个线程都需要打开表，连接数越大这个值要越大。

# thread_cache_size
含义：缓存可重用的线程数。
影响：这个参数设置线程的缓存，线程的创建和销毁的开销可能很大，因为每个线程的连接/断开都需要。如果应用程序中有大量的跳跃并发连接并且线程较多的话，就要加大它的值。它的目的是在通常的操作中无需创建新线程。
建议：通常至少设置为16。

# query_cache_size
含义：指定MySQL查询结果缓冲区的大小。
影响：如果应用程序有大量读，而且没有应用程序级别的缓存，那么这很有用。不过不要设置太大，因为维护它也需要不少开销，这会导致MySQL变慢。
建议：通常设置为 32-512Mb。设置完之后最好是跟踪一段时间，查看是否运行良好。在一定的负载压力下，如果缓存命中率太低了，就启用它，如果命中率已经不错了，就可以把他调小一点。对于2G的内存，先从16M开始，一倍一倍的增加，直到命中率比较稳定为止。

# query_cache_limit
含义：缓存单条SQL的结果集上限。默认4KB。
影响：当一条SQL返回的结果集大于这个限制的时候，将不被MySQL缓存。
建议：设置为1M即可。

# query_cache_min_res_unit
含义：缓存为每个数据集存放的最小内存大小，默认4KB。
影响：如果太小的话，将会导致MySQL经常访问内存块去获取信息，如果设置太大则浪费内存。
建议：如果SQL返回的结果集都很小的话，参数也可以调小一点，避免内存浪费。如果结果集大部分都大于4KB的话，则考虑加大参数。

# back_log
含义：在MySQL的连接请求等待队列中允许存放的最大连接请求数。系统默认值为50。
影响：如果系统在一个短时间内有很多连接，则需要增大该参数的值，该参数值指定到来的TCP/IP连接的侦听队列的大小。不同的操作系统在这个队列大小上有它自 己的限制。试图设定back_log高于你的操作系统的限制将是无效的。
建议：对于Linux系统推荐设置为小于512的整数。

# sort_buffer_size
含义：为每个需要进行排序的线程分配该大小的一个缓冲区。
影响：增加这值加速ORDER BY或GROUP BY操作。不过该参数对应的分配内存是每连接独占的，如果有100个连接，那么实际分配的总共排序缓冲区大小为100×sort_buffer_size。
建议：一般设置为2M观察变化再调整。

# read_buffer_size
含义：顺序查询操作所能使用的缓冲区大小。
影响：和sort_buffer_size一样，该参数对应的分配内存也是每连接独享。
建议：一般设置为2M再观察变化。

# read_rnd_buffer_size
含义：随机查询操作所能使用的缓冲区大小。
影响：每个线程独享。
建议：一般设置为2M再观察变化。

# query_cache_type
含义：查询缓冲类型。
影响：为1是使用缓冲，2是除非使用SQL_CACHE才进行缓冲。对于缓冲而言，数据并不是实时的，有一定的延时。但是对于实时性要求不高的查询短时间内多次执行，是不划算的，这个时候就需要缓存。并且缓存中是区分空格和大小写的，如果大小写不一致和空格不一致，也会认为是不同的SQL，不会利用到缓存。虽然不设置查询缓冲，有时可能带来性能上的损失，但有一些SQL语句需要实时地查询数据，或并不经常使用(可能一天就执行一两次)，这样就需要把缓冲关了，可以采用临时关闭的方法SELECT SQL_NO_CACHE。
建议：一般设置为1。

# MyISAM类：

myisam_sort_buffer_size
MyISAM表发生变化时重新排序所需的缓冲。一般64M足矣。

# InnoDB类

# innodb_buffer_pool_size
对InnoDB的效率影响很大。因为InnoDB会把尽可能多的数据和索引缓存在缓冲区，这个类似与Oracle的Buffer Pool：如果只采用InnoDB，可以把这个参数调大一点，大约内存的70%左右。
当然，如果数据量不会暴增并且不是特别大，这个参数还是不要太大了，浪费空间。

# innodb_additional_pool_size
对数据库性能影响不是很大，至少内存足够的机器上不会有什么影响。

# innodb_log_file_size
此参数为redo文件的大小
在高写入负载尤其是数据集很大的时候，这个值非常重要，值越高性能越好，不过可能会增加数据恢复的时候。我设置为128M。

# innodb_log_buffer_size
此参数为redo缓冲的大小，一般保证每秒产生的事物量在这个缓冲大小内即可
默认的设置在中等强度的写入负载及短事物处理时，性能还可以。但是存在大量更新操作或者负载较大时，就要慢慢增加这个参数的值了。不过不要设置太大，会浪费内存。它每秒都会刷新一次，所以不用设置超过1s所需的内存空间，16M足够了。

# innodb_flush_logs_at_trx_commit
此参数控制redo log提交的时候是否落盘
这个参数对InnoDB及其重要，设置不好的话会比MyISAM慢1000倍！默认是1，这就是说每次更新事务都会被提交到磁盘，这是非常消耗资源的，硬盘和内存的速度是明显数量级的差距。
设置为0是最快的，但是很不安全，全部在缓存中，一掉电全没了。
设置为1很不好，每次都去写硬盘，没有必要。
设置为2是比较好的，日志不刷新到磁盘上，只刷新到操作系统缓存上。然后每秒钟写缓存。相对于现在数据库每秒4K条左右的SQL，性能已经可以提高不少。
```

